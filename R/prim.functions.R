
#' @title  Find all box candidates for a given (sub)set
#' @description This function goes through all columns of the dataset and tries to findbox candidates based on the quantile alpha and minimum support min.support. Note that the indexes returned are those that have to be removed in order to create the box!
#' @param X Data frame with observations (may be a subset of original data)
#' @param alpha Quantile to peel off
#' @param min.support Minimal size of a box
#' @param N Number of rows of original subset
#' @return A list of potential boxes
#' @author Jurian Baas
prim.candidates.find <- function(X, alpha, min.support, N) {

  c <- lapply(X, function(col) {

    b <- list() # Used for storing indexes
    r <- list() # Used for storing rules

    # Do something different depending on data type
    if(is.numeric(col)) {

      b.min <- which(col < quantile(col, alpha))
      b.plus <- which(col > quantile(col, 1-alpha))

      # Make sure the resulting subsets have enough support
      if(length(b.min) > 0 & (length(col) - length(b.min)) / N >= min.support) {
        b <- c(b, min = list(b.min))
        r <- c(r, list(min = list(value = unname(quantile(col, alpha)), operator = "<", type = "numeric")))
      }
      if(length(b.plus) > 0 & (length(col) - length(b.plus)) / N >= min.support) {
        b <- c(b, plus = list(b.plus))
        r <- c(r, list(plus = list(value = unname(quantile(col, 1-alpha)), operator = ">", type = "numeric")))
      }

    } else if (is.logical(col)  ) {

      # Don't check if column consists of only T or F
      if(any(col) & any(!col)) {

        b.min <- which(col)
        b.plus <- which(!col)

        # Make sure the resulting subsets have enough support
        if((sum(!col) / N) >= min.support) {
          b <- c(b, min = list(b.min))
          r <- c(r, list(min = list(value = TRUE, operator = "==", type = "logical")))
        }
        if((sum(col) / N) >= min.support) {
          b <- c(b, plus = list(b.plus))
          r <- c(r, list(min = list(value = FALSE, operator = "==", type = "logical")))
        }
      }

    } else if (is.factor(col)) {

      # Reset levels just to be sure, so we don't use levels that no
      # longer exist due to them being removed in some previous iteration
      col <- factor(col)

      r <- lapply(levels(col), function(lvl) {
        paste("==", lvl)
      })

      # Create a box candidate for each level
      b <- lapply(levels(col), function(lvl) {

        box <- which(col == lvl)

        # Make sure the resulting subsets have enough support
        if((length(col) - length(box)) / N >= min.support) {
          return(box)
        }
        return(NA)
      })

      # Remove any NA's
      r <- r[!is.na(b)]
      b <- b[!is.na(b)]

    }

    return(list(rule = r, idx = b))

  })
  # Remove empty elements from the list
  c <- Filter(Negate(function(x) is.null(unlist(x))), c)
  return(c)
}

#' @description This function calculates the quality of the dependant variable y given some box candidate
#' @title Candidate box quality
#' @param y Vector of values on which to determine the quality
#' @param candidates List of candidates generated by prim.candidates.find()
#' @param quality.function Function to use for a quality measure (usually mean)
#' @return A list with the qualities of each supplied candidate box
#' @author Jurian Baas
prim.candidates.quality <- function(y, candidates, quality.function ) {

  # Extract index information
  candidates.idx <- lapply(candidates, function(box){box$idx})

  lapply(candidates.idx, function(c) {
    sapply(c, function(idx){
      quality.function(y[-idx])
    })
  })
}

#' @title Find optimal box candidate
#' @description This function goes through the box candidate qualities and finds the optimal candidate
#' @param candidates.quality List of candidate qualities generated by prim.candidates.quality()
#' @return Index of the optimal candidate in the candidates.quality argument
#' @author Jurian Baas
prim.candidates.best <- function(candidates.quality) {

  # Find the best value for each column
  m <- sapply(candidates.quality, function(x) c(idx = which.max(x), value = max(x)))
  # Find the best value among the previous best
  m.index <- which.max(m[2,])
  m.subindex <- m[1,m.index]

  names(m.index) <- names(candidates.quality)[m.index]

  # Return the indexes
  return(c(m.index, m.subindex))
}

#' @description  Main function for bump hunting using the Patient Rule Induction Method (PRIM).
#' @title Bump hunting using the Patient Rule Induction Method
#' @param X Data frame to find rules in
#' @param y Response vector, usually of type numeric
#' @param alpha Quantile to peel off for numerical variables
#' @param min.support Minimal size of a box to be valid
#' @param quality.function Which function to use to determine the quality of a box, defaults to mean
#' @return An S3 object of class prim.peel.result
#' @author Jurian Baas
#' @export
prim.default <- function(X, y, alpha, min.support, quality.function = mean) {

  result <- list()
  result$box.qualities <- quality.function(y)
  result$supports <- 1

  result$rule.names <- character()
  result$rule.operators <- character()
  result$rule.types <- character()
  result$rule.values <- list() # A list because we store multiple types of values (i.e. numerical, logical and factors)
  result$quality.function <- quality.function

  N <- nrow(X)

  repeat {

    if(nrow(X) / N <= min.support) break

    # Find box candidates
    candidates <- prim.candidates.find(X, alpha, min.support, N)

    if(length(candidates) == 0) break

    candidates.quality <- prim.candidates.quality(y, candidates, quality.function)
    candidates.final <- prim.candidates.best(candidates.quality)

    idx <- unlist(candidates[[ candidates.final[1] ]]$idx[candidates.final[2]])
    rule.info <- candidates[[ candidates.final[1] ]]$rule[[candidates.final[2]]]

    X <- X[-idx,]
    y <- y[-idx]

    result$box.qualities <- c(result$box.qualities, quality.function(y))
    result$supports <- c(result$supports, length(y)/N)

    result$rule.values <- c(result$rule.values, rule.info$value)
    result$rule.names <- c(result$rule.names, names(candidates.final)[1])
    result$rule.operators <- c(result$rule.operators, rule.info$operator)
    result$rule.types <- c(result$rule.types, rule.info$type)
  }

  result$rule.names <- factor(result$rule.names, levels = colnames(X))
  result$rule.operators <- factor(result$rule.operators, levels = c("<", ">", "=="))
  result$rule.types <- factor(result$rule.types, levels = c("numeric", "logical", "factor"))

  class(result) <- "prim.peel.result"

  result$superrule <- prim.condense.rules(result)
  result$call <- match.call()

  return(result)
}

#' @description Main function for bump hunting using the Patient Rule Induction Method (PRIM). N.B. Remember to remove the intercept from the formula!
#' @title Bump hunting using the Patient Rule Induction Method
#' @param formula Formula with a response and terms
#' @param data Data frame to find rules in
#' @param alpha Quantile to peel off for numerical variables
#' @param min.support Minimal size of a box to be valid
#' @param quality.function Which function to use to determine the quality of a box, defaults to mean
#' @return An S3 object of class prim.peel.result
#' @author Jurian Baas
#' @export
prim.formula <- function(formula, data, alpha, min.support, quality.function = mean) {

  mf <- stats::model.frame(formula=formula, data=data)
  X <- data.frame(stats::model.matrix(attr(mf, "terms"), data=mf)[,-1])
  y <- stats::model.response(mf)

  #return(X)
  if(is.null(y)) {
    stop("Data has no response variable, aborting...")
  }

  result <- prim.default(X, y, alpha, min.support, quality.function)
  result$formula <- formula
  return(result)
}

#' @description Plot an S3 object of class prim.peel.result
#' @title Plot PRIM peel result
#' @param peel.result An S3 object of class prim.peel.result
#' @author Jurian Baas
plot.prim.peel.result <- function(peel.result) {
  plot(
    peel.result$supports,
    peel.result$box.qualities,
    col= "blue", pch = 19, cex = 1, lty = "solid", lwd = 2,
    xlab = "Support", ylab = "Box quality",
    main = "PRIM peel result")
  text(
    peel.result$supports,
    peel.result$box.qualities,
    labels=c("", paste(peel.result$rule.names, peel.result$rule.operators, peel.result$rule.values) ),
    cex = 0.7, pos = 4)
}

#' @description Plot an S3 object of class prim.test.result
#' @title Plot PRIM test result
#' @param test.result An S3 object of class prim.test.result
#' @author Jurian Baas
plot.prim.test.result <- function(test.result) {
  plot(
    test.result$supports,
    test.result$box.qualities,
    col= "blue", pch = 19, cex = 1, lty = "solid", lwd = 2,
    xlab = "Support", ylab = "Box quality",
    main = "PRIM test result")
  text(
    test.result$supports,
    test.result$box.qualities,
    labels=c("", paste(test.result$rule.names, test.result$rule.operators, test.result$rule.values) ),
    cex = 0.7, pos = 4)
}

#' @description Generate a subset of the data using the rules in the supplied prim S3 object
#' @title PRIM subset creator
#' @param prim.object An S3 object of class prim.peel.result or prim.test result
#' @param X A data frame with at least those columns that were used in creating the prim S3 object
#' @return A subset of X
#' @author Jurian Baas
#' @export
prim.superrule.index <- function(prim.object, X) {

  if(class(prim.object) != "prim.peel.result" & class(prim.object) != "prim.test.result") {
    error("Supplied argument is not of class prim.peel.result or prim.test.result, aborting...")
  }
  return(with(X, eval(parse(text = prim.object$superrule))))
}

#' @description This function takes the result of prim() and applies it to new data. Usually the optimal box in the peeling process is not the best on unobserved data.
#' @title Bump hunting using the Patient Rule Induction Method
#' @param peel.result An S3 object of class prim.peel.result
#' @param X A data frame with at least those columns that were used in creating the prim.peel.result S3 object
#' @param y Response vector, usually of type numeric
#' @return An S3 object of type prim.test.result
#' @author Jurian Baas
#' @export
prim.test <- function(peel.result, X, y) {

  if(class(peel.result) != "prim.peel.result") {
    error("Supplied argument is not of class prim.peel.result, aborting...")
  }

  quality.function <- peel.result$quality.function

  N <- nrow(X)
  i <- 1

  result <- list()
  class(result) <- "prim.test.result"
  result$box.qualities <- quality.function(y)
  result$supports <- 1
  result$redundant <- integer()
  result$rule.names <- character()
  result$rule.operators <- character()
  result$rule.types <- character()
  result$rule.values <- list() # A list because we store multiple types of values (i.e. numerical, logical and factors)
  result$quality.function <- quality.function

  repeat {

    if(i > length(peel.result$rule.names)) break

    rule.info <- list(
      name = as.character(peel.result$rule.names[i]),
      operator = as.character(peel.result$rule.operators[i]),
      value = peel.result$rule.values[i],
      type = as.character(peel.result$rule.types[i])
    )
    rule <- paste0("X$", paste( rule.info$name, rule.info$operator, rule.info$value))

    idx <- eval(parse(text = rule))

    # Check if this rule has any observations in the test data
    if(sum(idx) > 0) {

      X <- X[!idx,]
      y <- y[!idx]

      result$box.qualities <- c(result$box.qualities, quality.function(y))
      result$supports <- c(result$supports, length(y)/N)

      result$rule.values <- c(result$rule.values, rule.info$value)
      result$rule.names <- c(result$rule.names, rule.info$name)
      result$rule.operators <- c(result$rule.operators, rule.info$operator)
      result$rule.types <- c(result$rule.types, rule.info$type)

    } else {

      result$redundant <- c(result$redundant, i)

    }

    i <- i + 1
  }

  result$rule.names <- factor(result$rule.names, levels = colnames(X))
  result$rule.operators <- factor(result$rule.operators, levels = c("<", ">", "=="))
  result$rule.types <- factor(result$rule.types, levels = c("numeric", "logical", "factor"))

  result$superrule <- prim.condense.rules(result)
  result$call <- match.call()

  return(result)
}

#' @description This function condenses the many (redundant) rules of an S3 object of class prim.peel.result or prim.test.result to a single rule.
#' @title Condense multiple (redundant) rules
#' @param prim.object An S3 object of class prim.peel.result or prim.test.result
#' @return The condensed rule as a single string
#' @author Jurian Baas
prim.condense.rules <- function(prim.object) {

  if(class(prim.object) != "prim.peel.result" & class(prim.object) != "prim.test.result"){
    error("Supplied argument is not of class prim.peel.result or prim.test.result, aborting...")
  }

  # Search for the rules leading up to the best box
  rule.idx <- 1:(which.max(prim.object$box.qualities)-1)

  # Combine the lists into a single data frame
  t <- data.frame (
    name = factor(prim.object$rule.names[rule.idx]),
    operator = factor(prim.object$rule.operators[rule.idx]),
    value = as.character(prim.object$rule.values[rule.idx]),
    score = prim.object$box.qualities[rule.idx],
    type = factor(prim.object$rule.types[rule.idx])
  )
  levels(t$operator) <-  c(">=", "<=", "!=")

  # Group by name first
  t <- by(t, t$name, function(x) {

    # Group by operator in the name subgroup
    by(x, factor( x$operator), function(y) {
      # Find the rule with the largest associated score
      y <- y[which.max( y$score),]
      # Return this rule as a proper string
      return(paste(y$name, y$operator, y$value))
    })
  })

  # Collapse to character vector, collapse further to a string combined with '&' sign and return
  return(paste(unlist(t), collapse = " & "))
}

#' @title PRIM covering algorithm
#' @description Temporary description
#' @author Jurian Baas
#' @export
prim.cover <- function(X, y, alpha, min.support, train.fraction = 0.6, max.boxes = NA) {

  N <- nrow(X) * min.support
  box.nr <- 1
  covers <- list()

  repeat {

    if(!is.na(max.boxes) & box.nr > max.boxes) break;
    if(nrow(X) < N) break;

    train <- sample(1:nrow(X), nrow(X) * train.fraction)

    p.train <- prim.default(X[train], y[train], alpha, min.support)
    p.test <- prim.test(p.train, X[-train], y[-train])

    idx <- prim.superrule.index(p.test, X)

    X <- X[!idx]
    y <- y[!idx]
    box.nr <- box.nr + 1

    covers <- c(covers, p.test$superrule)

  }

  return(covers)
}

#' @title PRIM main entrance
#' @description Temporary description
#' @author Jurian Baas
#' @export
prim <- function() {

}

