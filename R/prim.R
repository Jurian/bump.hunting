
#' @title  Find all box candidates for a given (sub)set
#' @description This function goes through all columns of the dataset and tries to findbox candidates based on the quantile peeling.quantile and minimum support min.support. Note that the indexes returned are those that have to be removed in order to create the box!
#' @param X Data frame with observations (may be a subset of original data)
#' @param y Dependent variable, usually a numeric vector
#' @param peeling.quantile Quantile to peel off
#' @param min.support Minimal size of a box
#' @param N Number of rows of original subset
#' @param quality.function Function to use to determine box quality
#' @return A list of potential boxes
#' @author Jurian Baas
#' @importFrom stats quantile
prim.candidates.find <- function(X, y, peeling.quantile, min.support, N, quality.function) {

  c <- lapply(X, function(col) {
    r <- list()
    # Do something different depending on data type
    if(is.numeric(col)) {

      quantile.min <- stats::quantile(col, peeling.quantile)
      quantile.plus <- stats::quantile(col, 1 - peeling.quantile)

      idx.min <- col < quantile.min
      idx.plus <- col > quantile.plus

      if(sum(idx.min) > 0 & (length(col) - sum(idx.min)) / N >= min.support) {
        r <- c(r,
               list(
                 min = list(
                   value = unname(quantile.min),
                   operator = ">=",
                   type = "numeric",
                   quality = quality.function(y[!idx.min]),
                   idx = which(idx.min),
                   size = sum(idx.min)/ length(col)
                 )
               )
        )
      }

      if(sum(idx.plus) > 0 & (length(col) - sum(idx.plus)) / N >= min.support) {
        r <- c(r,
               list(
                 plus = list(
                   value = unname(quantile.plus),
                   operator = "<=",
                   type = "numeric",
                   quality = quality.function(y[!idx.plus]),
                   idx = which(idx.plus),
                   size = sum(idx.plus)/ length(col)
                 )
               )
        )
      }


    } else if (is.logical(col)  ) {

      # Don't check if column consists of only T or F
      if(any(col) & any(!col)) {

        idx.min <- col
        idx.plus <- !col

        # Make sure the resulting subsets have enough support
        if((sum(!col) / N) >= min.support) {
          r <- c(r,
                 list(
                   min = list(
                     value = FALSE,
                     operator = "==",
                     type = "logical",
                     quality = quality.function(y[!idx.min]),
                     idx = which(idx.min),
                     size = sum(idx.min)/ length(col)
                   )
                 )
          )
        }
        if((sum(col) / N) >= min.support) {
          r <- c(r,
                 list(
                   plus = list(
                     value = TRUE,
                     operator = "==",
                     type = "logical",
                     quality = quality.function(y[!idx.plus]),
                     idx = which(idx.plus),
                     size = sum(idx.plus)/ length(col)
                   )
                 )
          )
        }
      }

    } else if (is.factor(col)) {

      # Reset levels just to be sure, so we don't use levels that no
      # longer exist due to them being removed in some previous iteration
      col <- factor(col)

      r <- lapply(levels(col), function(lvl) {

        idx <- col == lvl

        # Make sure the resulting subsets have enough support
        if((length(col) - sum(idx)) / N >= min.support) {
          box <- list(
            value = lvl,
            operator = "!=",
            type = "factor",
            quality = quality.function(y[!idx]),
            idx = which(idx),
            size = sum(idx)/ length(col)
          )
          return(box)
        }
        return(NULL)
      })
    }
    return(r)

  })
  # Remove empty elements from the list
  c <- Filter(Negate(function(x) is.null(unlist(x))), c)
  return(c)
}

#' @title Find optimal box candidate
#' @description This function goes through the box candidate qualities and finds the optimal candidate
#' @param candidates List of candidate generated by prim.candidates.find()
#' @return A list with the optimal candidate information
#' @author Jurian Baas
prim.candidates.best <- function(candidates) {

  qualities <- sapply(candidates, function(x){
    c(
      min = ifelse(is.null(x$min$quality), NA, x$min$quality),
      plus = ifelse(is.null(x$plus$quality), NA, x$plus$quality))
  })

  idx <- which(qualities == max(qualities, na.rm = T), arr.ind = T)

  # Break any ties at random
  if(nrow(idx) > 1) {

    sizes <- sapply(candidates, function(x){
      c(
        min = ifelse(is.null(x$min$size), NA, x$min$size),
        plus = ifelse(is.null(x$plus$size), NA, x$plus$size))
    })

    # Use a weighted random strategy, based on the size of the resulting subset
    idx <- idx[sample(nrow(idx), 1, prob = 1 - sizes[idx]),]
  }

  best <- candidates[[ idx[2] ]][[ rownames(qualities)[idx[1]] ]]
  best$name <- colnames(qualities)[idx[2]]

  return(best)
}

#' @description  Main function for bump hunting using the Patient Rule Induction Method (PRIM).
#' @title Bump hunting using the Patient Rule Induction Method
#' @param X Data frame to find rules in
#' @param y Response vector, usually of type numeric
#' @param peeling.quantile Quantile to peel off for numerical variables
#' @param min.support Minimal size of a box to be valid, as a fraction
#' @param quality.function Which function to use to determine the quality of a box, defaults to mean
#' @return An S3 object of class prim.peel.result
#' @author Jurian Baas
#' @export
prim.default <- function(X, y, peeling.quantile, min.support, quality.function = mean) {

  if(!is.data.frame(X)) stop("Paramter X has to be a data frame")
  if(!is.vector(y)) stop("Parameter y has to be a vector")
  if(nrow(X) != length(y)) stop("Parameters X and y are not of same size")
  if(peeling.quantile <= 0) stop("Peeling quantile must be positive")
  if(peeling.quantile >= 1) stop("Peeling quantile must be a fraction smaller than 1")
  if(min.support <= 0) stop("Minimum support must be positive")
  if(min.support >= 1) stop("Minimum support must be a fraction smaller than 1")

  result <- list()
  result$box.qualities <- quality.function(y)
  result$supports <- 1

  result$rule.names <- character()
  result$rule.operators <- character()
  result$rule.types <- character()
  result$rule.values <- list() # A list because we store multiple types of values (i.e. numerical, logical and factors)
  result$quality.function <- quality.function

  N <- nrow(X)

  repeat {

    if(nrow(X) / N <= min.support) break

    # Find box candidates
    candidates <- prim.candidates.find(X, y, peeling.quantile, min.support, N, quality.function)

    if(length(candidates) == 0) break

    cf <- prim.candidates.best(candidates)

    X <- X[-cf$idx,]
    y <- y[-cf$idx]

    result$box.qualities <- c(result$box.qualities, quality.function(y))
    result$supports <- c(result$supports, length(y)/N)

    result$rule.values <- c(result$rule.values, cf$value)
    result$rule.names <- c(result$rule.names, cf$name)
    result$rule.operators <- c(result$rule.operators, cf$operator)
    result$rule.types <- c(result$rule.types, cf$type)
  }

  result$rule.names <- factor(result$rule.names, levels = colnames(X))
  result$rule.operators <- factor(result$rule.operators, levels = c(">=", "<=", "==", "!="))
  result$rule.types <- factor(result$rule.types, levels = c("numeric", "logical", "factor"))

  class(result) <- "prim.peel.result"

  result$superrule <- prim.condense.rules(result)
  result$call <- match.call()

  return(result)
}

#' @description Main function for bump hunting using the Patient Rule Induction Method (PRIM). N.B. Remember to remove the intercept from the formula!
#' @title Bump hunting using the Patient Rule Induction Method
#' @param formula Formula with a response and terms
#' @param data Data frame to find rules in
#' @param peeling.quantile Quantile to peel off for numerical variables
#' @param min.support Minimal size of a box to be valid
#' @param quality.function Which function to use to determine the quality of a box, defaults to mean
#' @return An S3 object of class prim.peel.result
#' @author Jurian Baas
#' @importFrom stats model.frame model.response
#' @export
prim.formula <- function(formula, data, peeling.quantile, min.support, quality.function = mean) {

  X <- stats::model.frame(formula = formula, data = data)
  #X <- data.frame(stats::model.matrix(attr(mf, "terms"), data = mf)[,-1])
  y <- stats::model.response(X)
  X <- X[,-1]

  #return(X)
  if(is.null(y)) {
    stop("Data has no response variable, aborting...")
  }

  result <- prim.default(X, y, peeling.quantile, min.support, quality.function)
  result$formula <- formula
  return(result)
}

#' @description Plot an S3 object of class prim.peel.result
#' @title Plot PRIM peel result
#' @param x An S3 object of class prim.peel.result
#' @param ... Optional arguments to pass on
#' @author Jurian Baas
#' @export
#' @importFrom graphics plot text
plot.prim.peel.result <- function(x, ...) {
  graphics::plot(
    x$supports,
    x$box.qualities,
    col= "blue", pch = 19, cex = 1, lty = "solid", lwd = 2,
    xlab = "Support", ylab = "Box quality",
    main = "PRIM peel result",
    ...)
  graphics::text(
    x$supports,
    x$box.qualities,
    labels=c("", paste(x$rule.names, x$rule.operators, x$rule.values) ),
    cex = 0.7, pos = 4)
}

#' @description Plot an S3 object of class prim.test.result
#' @title Plot PRIM test result
#' @param x An S3 object of class prim.test.result
#' @param ... Optional arguments to pass on
#' @author Jurian Baas
#' @export
#' @importFrom graphics plot text
plot.prim.test.result <- function(x, ...) {
  graphics::plot(
    x$supports,
    x$box.qualities,
    col= "blue", pch = 19, cex = 1, lty = "solid", lwd = 2,
    xlab = "Support", ylab = "Box quality",
    main = "PRIM test result",
    ...)
  graphics::text(
    x$supports,
    x$box.qualities,
    labels=c("", paste(x$rule.names, x$rule.operators, x$rule.values) ),
    cex = 0.7, pos = 4)
}

#' @title
#' @description
#'
#'
#'
#' @author Jurian Baas
#' @export
summary.prim.peel.result <- function(x, ...) {
  cat("  ======================================", "\n")
  cat("  ========== PRIM PEEL RESULT ==========", "\n")
  cat("  ======================================", "\n")
  cat("\n")
  best.box.idx <- which.max(x$box.qualities)
  cat("  ============== BEST BOX ==============", "\n")
  cat("  quality: ", x$box.qualities[best.box.idx], "\n")
  cat("  support: ", x$supports[best.box.idx], "\n")
  cat("\n")
  cat("  ================ RULES ===============", "\n")
  cat(" ", paste0(x$superrule, collapse = " & \n  "))
}

#' @title
#' @description
#'
#'
#'
#' @author Jurian Baas
#' @export
summary.prim.test.result <- function(x, ...) {
  cat("  ======================================", "\n")
  cat("  ========== PRIM PEEL RESULT ==========", "\n")
  cat("  ======================================", "\n")
  cat("\n")
  best.box.idx <- which.max(x$box.qualities)
  cat("  ============== BEST BOX ==============", "\n")
  cat("  quality: ", x$box.qualities[best.box.idx], "\n")
  cat("  support: ", x$supports[best.box.idx], "\n")
  cat("\n")
  cat("  ================ RULES ===============", "\n")
  cat(" ", paste0(x$superrule, collapse = " & \n  "))
}

#' @description Generate a subset of the data using the rules in the supplied prim S3 object
#' @title PRIM subset creator
#' @param prim.object An S3 object of class prim.peel.result or prim.test result
#' @param X A data frame with at least those columns that were used in creating the prim S3 object
#' @return A subset of X
#' @author Jurian Baas
#' @export
prim.superrule.index <- function(prim.object, X) {

  if(class(prim.object) != "prim.peel.result" & class(prim.object) != "prim.test.result") {
    stop("Supplied argument is not of class prim.peel.result or prim.test.result, aborting...")
  }
  return(with(X, eval(parse(text = paste0(prim.object$superrule, collapse = " & ")))))
}

#' @description This function takes the result of prim() and applies it to new data. Usually the optimal box in the peeling process is not the best on unobserved data.
#' @title Bump hunting using the Patient Rule Induction Method
#' @param peel.result An S3 object of class prim.peel.result
#' @param X A data frame with at least those columns that were used in creating the prim.peel.result S3 object
#' @param y Response vector, usually of type numeric
#' @return An S3 object of type prim.test.result
#' @author Jurian Baas
#' @export
prim.test <- function(peel.result, X, y) {

  if(class(peel.result) != "prim.peel.result") {
    stop("Supplied argument is not of class prim.peel.result, aborting...")
  }

  quality.function <- peel.result$quality.function

  N <- nrow(X)
  i <- 1

  result <- list()
  class(result) <- "prim.test.result"
  result$box.qualities <- quality.function(y)
  result$supports <- 1
  result$redundant <- integer()
  result$rule.names <- character()
  result$rule.operators <- character()
  result$rule.types <- character()
  result$rule.values <- list() # A list because we store multiple types of values (i.e. numerical, logical and factors)
  result$quality.function <- quality.function

  repeat {

    if(i > length(peel.result$rule.names)) break

    rule.info <- list(
      name = as.character(peel.result$rule.names[i]),
      operator = as.character(peel.result$rule.operators[i]),
      value = peel.result$rule.values[i],
      type = as.character(peel.result$rule.types[i])
    )

    rule <- paste( rule.info$name, rule.info$operator, rule.info$value)
    idx <- !with(X, eval(parse(text = rule)))

    # Check if this rule has any observations in the test data
    if(sum(idx) > 0) {

      X <- X[!idx,]
      y <- y[!idx]

      result$box.qualities <- c(result$box.qualities, quality.function(y))
      result$supports <- c(result$supports, length(y)/N)

      result$rule.values <- c(result$rule.values, rule.info$value)
      result$rule.names <- c(result$rule.names, rule.info$name)
      result$rule.operators <- c(result$rule.operators, rule.info$operator)
      result$rule.types <- c(result$rule.types, rule.info$type)

    } else {

      result$redundant <- c(result$redundant, i)

    }

    i <- i + 1
  }

  result$rule.names <- factor(result$rule.names, levels = colnames(X))
  result$rule.operators <- factor(result$rule.operators, levels = c(">=", "<=", "==", "!="))
  result$rule.types <- factor(result$rule.types, levels = c("numeric", "logical", "factor"))

  result$superrule <- prim.condense.rules(result)
  result$call <- match.call()

  return(result)
}

#' @description This function condenses the many (redundant) rules of an S3 object of class prim.peel.result or prim.test.result to a single rule.
#' @title Condense multiple (redundant) rules
#' @param prim.object An S3 object of class prim.peel.result or prim.test.result
#' @return The condensed rule as a single string
#' @author Jurian Baas
prim.condense.rules <- function(prim.object) {

  if(class(prim.object) != "prim.peel.result" & class(prim.object) != "prim.test.result"){
    stop("Supplied argument is not of class prim.peel.result or prim.test.result, aborting...")
  }

  # Search for the rules leading up to the best box
  rule.idx <- 1:(which.max(prim.object$box.qualities)-1)

  # Combine the lists into a single data frame
  t <- data.frame (
    name = factor(prim.object$rule.names[rule.idx]),
    operator = factor(prim.object$rule.operators[rule.idx]),
    value = as.character(prim.object$rule.values[rule.idx]),
    score = prim.object$box.qualities[rule.idx],
    type = factor(prim.object$rule.types[rule.idx])
  )
  #levels(t$operator) <-  c(">=", "<=", "!=")

  # Group by name first
  t <- by(t, t$name, function(x) {

    # Group by operator in the name subgroup
    by(x, factor( x$operator), function(y) {
      # Find the rule with the largest associated score
      y <- y[which.max( y$score),]
      # Return this rule as a proper string
      return(paste(y$name, y$operator, y$value))
    })
  })

  # Collapse to character vector
  return(unname(unlist(as.vector(t))))
}

#' @title PRIM covering algorithm
#' @description Temporary description
#' @param X Data frame to find rules in
#' @param y Response vector, usually of type numeric
#' @param peeling.quantile Quantile to peel off for numerical variables
#' @param min.support Minimal size of a box to be valid
#' @param train.fraction Train-test split fraction used in validation
#' @param max.boxes Optional maximum number of boxes
#' @author Jurian Baas
#' @export
prim.cover <- function(X, y, peeling.quantile, min.support, train.fraction = 0.6, max.boxes = NA) {

  N <- nrow(X) * min.support
  box.nr <- 1
  covers <- list()

  repeat {

    if(!is.na(max.boxes) & box.nr > max.boxes) break;
    if(nrow(X) < N) break;

    train <- sample(1:nrow(X), nrow(X) * train.fraction)

    p.train <- prim.default(X[train], y[train], peeling.quantile, min.support)
    p.test <- prim.test(p.train, X[-train], y[-train])

    idx <- prim.superrule.index(p.test, X)

    X <- X[!idx]
    y <- y[!idx]
    box.nr <- box.nr + 1

    covers <- c(covers, p.test$superrule)

  }

  return(covers)
}

#' @title PRIM main entrance
#' @description Temporary description
#' @author Jurian Baas
#' @export
prim <- function() {

}

