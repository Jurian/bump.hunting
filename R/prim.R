
#' @title  Find all box candidates for a given (sub)set
#' @description This function goes through all columns of the dataset and tries to findbox candidates based on the quantile peeling.quantile and minimum support min.support. Note that the indexes returned are those that have to be removed in order to create the box!
#' @param X Data frame with observations (may be a subset of original data)
#' @param y Dependent variable, usually a numeric vector
#' @param peeling.quantile Quantile to peel off
#' @param min.support Minimal size of a box
#' @param N Number of rows of original subset
#' @param quality.function Function to use to determine box quality
#' @return A list of potential boxes
#' @author Jurian Baas
#' @importFrom stats quantile
prim.candidates.find <- function(X, y, peeling.quantile, min.support, N, quality.function) {

  c <- lapply(X, function(col) {
    r <- list()
    # Do something different depending on data type
    if(is.numeric(col)) {

      quantile.min <- stats::quantile(col, peeling.quantile)
      quantile.plus <- stats::quantile(col, 1 - peeling.quantile)

      idx.min <- col < quantile.min
      idx.plus <- col > quantile.plus

      if(sum(idx.min) > 0 & (length(col) - sum(idx.min)) / N >= min.support) {
        r <- c(r,
               list(
                 min = list(
                   value = unname(quantile.min),
                   operator = ">=",
                   type = "numeric",
                   quality = quality.function(y[!idx.min]),
                   idx = which(idx.min),
                   size = sum(idx.min)/ length(col)
                 )
               )
        )
      }

      if(sum(idx.plus) > 0 & (length(col) - sum(idx.plus)) / N >= min.support) {
        r <- c(r,
               list(
                 plus = list(
                   value = unname(quantile.plus),
                   operator = "<=",
                   type = "numeric",
                   quality = quality.function(y[!idx.plus]),
                   idx = which(idx.plus),
                   size = sum(idx.plus)/ length(col)
                 )
               )
        )
      }


    } else if (is.logical(col)  ) {

      # Don't check if column consists of only T or F
      if(any(col) & any(!col)) {

        idx.min <- col
        idx.plus <- !col

        # Make sure the resulting subsets have enough support
        if((sum(!col) / N) >= min.support) {
          r <- c(r,
                 list(
                   min = list(
                     value = FALSE,
                     operator = "==",
                     type = "logical",
                     quality = quality.function(y[!idx.min]),
                     idx = which(idx.min),
                     size = sum(idx.min)/ length(col)
                   )
                 )
          )
        }
        if((sum(col) / N) >= min.support) {
          r <- c(r,
                 list(
                   plus = list(
                     value = TRUE,
                     operator = "==",
                     type = "logical",
                     quality = quality.function(y[!idx.plus]),
                     idx = which(idx.plus),
                     size = sum(idx.plus)/ length(col)
                   )
                 )
          )
        }
      }

    } else if (is.factor(col)) {

      # Reset levels just to be sure, so we don't use levels that no
      # longer exist due to them being removed in some previous iteration
      col <- factor(col)

      r <- lapply(levels(col), function(lvl) {

        idx <- col == lvl

        # Make sure the resulting subsets have enough support
        if((length(col) - sum(idx)) / N >= min.support) {
          box <- list(
            value = lvl,
            operator = "!=",
            type = "factor",
            quality = quality.function(y[!idx]),
            idx = which(idx),
            size = sum(idx)/ length(col)
          )
          return(box)
        }
        return(NULL)
      })
    }
    return(r)

  })
  # Remove empty elements from the list
  c <- Filter(Negate(function(x) is.null(unlist(x))), c)
  return(c)
}

#' @title Find optimal box candidate
#' @description This function goes through the box candidate qualities and finds the optimal candidate
#' @param candidates List of candidate generated by prim.candidates.find()
#' @return A list with the optimal candidate information
#' @author Jurian Baas
prim.candidates.best <- function(candidates) {

  qualities <- sapply(candidates, function(x){
    c(
      min = ifelse(is.null(x$min$quality), NA, x$min$quality),
      plus = ifelse(is.null(x$plus$quality), NA, x$plus$quality))
  })

  idx <- which(qualities == max(qualities, na.rm = T), arr.ind = T)

  # Break any ties at (weighted!) random
  if(nrow(idx) > 1) {

    sizes <- sapply(candidates, function(x){
      c(
        min = ifelse(is.null(x$min$size), NA, x$min$size),
        plus = ifelse(is.null(x$plus$size), NA, x$plus$size))
    })

    # Use a weighted random strategy, based on the size of the resulting subset
    idx <- idx[sample(nrow(idx), 1, prob = 1 - sizes[idx]),]
  }

  best <- candidates[[ idx[2] ]][[ rownames(qualities)[idx[1]] ]]
  best$name <- colnames(qualities)[idx[2]]

  return(best)
}

#' @description  Main function for bump hunting using the Patient Rule Induction Method (PRIM).
#' @title Bump hunting using the Patient Rule Induction Method
#' @param X Data frame to find rules in
#' @param y Response vector, usually of type numeric
#' @param peeling.quantile Quantile to peel off for numerical variables
#' @param min.support Minimal size of a box to be valid, as a fraction
#' @param quality.function Which function to use to determine the quality of a box, defaults to mean
#' @return An S3 object of class prim.peel
#' @author Jurian Baas
#' @export
prim.default <- function(X, y, peeling.quantile, min.support, quality.function = mean) {

  if(!is.data.frame(X)) stop("Paramter X has to be a data frame")
  if(!is.vector(y)) stop("Parameter y has to be a vector")
  if(nrow(X) != length(y)) stop("Parameters X and y are not of same size")
  if(peeling.quantile <= 0) stop("Peeling quantile must be positive")
  if(peeling.quantile >= 1) stop("Peeling quantile must be a fraction smaller than 1")
  if(min.support <= 0) stop("Minimum support must be positive")
  if(min.support >= 1) stop("Minimum support must be a fraction smaller than 1")

  result <- list()
  result$box.qualities <- quality.function(y)
  result$supports <- 1

  result$rule.names <- character()
  result$rule.operators <- character()
  result$rule.types <- character()
  result$rule.values <- list() # A list because we store multiple types of values (i.e. numerical, logical and factors)
  result$quality.function <- quality.function
  result$N <- nrow(X)
  result$avg.quality <- quality.function(y)

  repeat {

    if(nrow(X) / result$N <= min.support) break

    # Find box candidates
    candidates <- prim.candidates.find(X, y, peeling.quantile, min.support, result$N, quality.function)

    if(length(candidates) == 0) break

    cf <- prim.candidates.best(candidates)

    X <- X[-cf$idx,]
    y <- y[-cf$idx]

    result$box.qualities <- c(result$box.qualities, quality.function(y))
    result$supports <- c(result$supports, length(y) / result$N)

    result$rule.values <- c(result$rule.values, cf$value)
    result$rule.names <- c(result$rule.names, cf$name)
    result$rule.operators <- c(result$rule.operators, cf$operator)
    result$rule.types <- c(result$rule.types, cf$type)
  }

  result$rule.names <- factor(result$rule.names, levels = colnames(X))
  result$rule.operators <- factor(result$rule.operators, levels = c(">=", "<=", "==", "!="))
  result$rule.types <- factor(result$rule.types, levels = c("numeric", "logical", "factor"))

  class(result) <- "prim.peel"

  result$superrule <- prim.condense.rules(result)
  result$call <- match.call()

  return(result)
}

#' @description Main function for bump hunting using the Patient Rule Induction Method (PRIM). N.B. Remember to remove the intercept from the formula!
#' @title Bump hunting using the Patient Rule Induction Method
#' @param formula Formula with a response and terms
#' @param data Data frame to find rules in
#' @param peeling.quantile Quantile to peel off for numerical variables
#' @param min.support Minimal size of a box to be valid
#' @param quality.function Which function to use to determine the quality of a box, defaults to mean
#' @return An S3 object of class prim.peel
#' @author Jurian Baas
#' @importFrom stats model.frame model.response
#' @export
prim.formula <- function(formula, data, peeling.quantile, min.support, quality.function = mean) {

  X <- stats::model.frame(formula = formula, data = data)
  y <- stats::model.response(X)
  X <- X[,-1]

  if(is.null(y)) {
    stop("Data has no response variable, aborting...")
  }

  result <- prim.default(X, y, peeling.quantile, min.support, quality.function)
  result$formula <- formula
  return(result)
}

#' @description Plot an S3 object of class prim.peel
#' @title Plot PRIM peel result
#' @param x An S3 object of class prim.peel
#' @param ... Optional arguments to pass on
#' @author Jurian Baas
#' @export
#' @importFrom graphics par plot points text
plot.prim.peel <- function(x, ...) {
  graphics::par(bty = "l")
  graphics::plot (
    x$supports,
    x$box.qualities,
    xlim = c(1, 0),
    type = "n",
    xlab = "Support", ylab = "Box quality",
    main = "PRIM peel result",
    ...)
  graphics::lines (
    x$supports,
    x$box.qualities
  )
  graphics::points (
    x$supports,
    x$box.qualities,
    col= "royalblue4", pch = 19, cex = 1, lty = "solid", lwd = 2)
  graphics::text (
    x$supports,
    x$box.qualities,
    labels = c("", paste(x$rule.names, x$rule.operators, x$rule.values) ),
    cex = 0.7, pos = 4, col = "orangered4", font = 2)
}

#' @description Plot an S3 object of class prim.validate
#' @title Plot PRIM test result
#' @param x An S3 object of class prim.validate
#' @param ... Optional arguments to pass on
#' @author Jurian Baas
#' @export
#' @importFrom graphics par plot points text
plot.prim.validate <- function(x, ...) {
  graphics::par(bty = "l")
  graphics::plot (
    x$supports,
    x$box.qualities,
    xlim = c(1, 0),
    type = "n",
    xlab = "Support", ylab = "Box quality",
    main = "PRIM validate result",
    ...)
  graphics::lines (
    x$supports,
    x$box.qualities
  )
  graphics::points (
    x$supports,
    x$box.qualities,
    col= "royalblue4", pch = 19, cex = 1, lty = "solid", lwd = 2)
  graphics::text (
    x$supports,
    x$box.qualities,
    labels = c("", paste(x$rule.names, x$rule.operators, x$rule.values) ),
    cex = 0.7, pos = 4, col = "orangered4", font = 2)
}

#' @description Plot an S3 object of class prim.cover
#' @title Plot PRIM cover result
#' @param x An S3 object of class prim.cover
#' @param ... Optional arguments to pass on
#' @author Jurian Baas
#' @export
#' @importFrom graphics par plot lines points text
plot.prim.cover <- function(x, ...) {

  dat <- data.frame(t(sapply(x$covers, function(c) {
    c( supports = c$cov.support / c$cov.N, box.qualities = c$cov.quality)
  })))
  graphics::par(bty = "l")
  graphics::plot (
    dat$supports,
    dat$box.qualities,
    type = "n",
    xlim = c(0,1),
    xlab = "Relative support", ylab = "Relative box quality",
    main = "PRIM cover result",
    ...)
  graphics::lines (
    x = dat$supports,
    y = dat$box.qualities,
    #x1 = dat$supports[-1],
    #y1 = dat$box.qualities[-1],
    lwd = 2,
    col = "ivory4"
  )
  graphics::points (
    dat$supports,
    dat$box.qualities,
    col= "royalblue4", pch = 19, cex = 1, lty = "solid", lwd = 2)
  graphics::text (
    dat$supports,
    dat$box.qualities,
    labels = paste("Cover", 1 : length(x$covers)),
    cex = 0.7, pos = 2, col = "orangered4", font = 2)
}

#' @title Summarize a PRIM peeling result object
#' @description Summarize a PRIM peeling result object
#' @param object An S3 object of class prim.peel
#' @param ... Optional arguments to pass on
#' @param round Optional setting to disable rounding
#' @param digits Optional setting to control nr of digits to round
#' @author Jurian Baas
#' @export
summary.prim.peel <- function(object, ..., round = T, digits = 2) {
  cat("  ======================================", "\n")
  cat("  ========== PRIM PEEL RESULT ==========", "\n")
  cat("  ======================================", "\n")
  cat("\n")
  best.box.idx <- which.max(object$box.qualities)

  if(round) {

    cat("  Original set size: ", object$N, "\n")
    cat("  Original set quality: ", round(object$avg.quality, digits), "\n")
    cat("\n")
    cat("  ============== BEST BOX ==============", "\n")
    cat("  Box quality: ", round(object$box.qualities[best.box.idx], digits), "(", round(object$box.qualities[best.box.idx] / object$avg.quality, digits), ") \n")
    cat("  Box support: ", round(object$supports[best.box.idx], digits), " (", object$supports[best.box.idx] * object$N, ") \n")
    cat("\n")
    cat("  ================ RULES ===============", "\n")
    cat(" ", paste0(object$superrule, collapse = "\n  "))

  } else {

    cat("  Original set size: ", object$N, "\n")
    cat("  Original set quality: ", object$avg.quality, "\n")
    cat("\n")
    cat("  ============== BEST BOX ==============", "\n")
    cat("  Box quality: ", object$box.qualities[best.box.idx], "\n")
    cat("  Box support: ", object$supports[best.box.idx], " (", object$supports[best.box.idx] * object$N, ") \n")
    cat("\n")
    cat("  ================ RULES ===============", "\n")
    cat(" ", paste0(object$superrule, collapse = "\n  "))
  }
}

#' @title Summarize a PRIM test result object
#' @description Summarize a PRIM test result object
#' @param object An S3 object of class prim.validate
#' @param ... Optional arguments to pass on
#' @param round Optional setting to disable rounding
#' @param digits Optional setting to control nr of digits to round
#' @author Jurian Baas
#' @export
summary.prim.validate <- function(object, ..., round = T, digits = 2) {
  cat("  ======================================", "\n")
  cat("  ========== PRIM TEST RESULT ==========", "\n")
  cat("  ======================================", "\n")
  cat("\n")
  best.box.idx <- which.max(object$box.qualities)
  if(round) {

    cat("  Original set size: ", object$N, "\n")
    cat("  Original set quality: ", round(object$avg.quality, digits), "\n")
    cat("\n")
    cat("  ============== BEST BOX ==============", "\n")
    cat("  Box quality: ", round(object$box.qualities[best.box.idx], digits), "(", round(object$box.qualities[best.box.idx] / object$avg.quality, digits), ") \n")
    cat("  Box support: ", round(object$supports[best.box.idx], digits), " (", object$supports[best.box.idx] * object$N, ") \n")
    cat("\n")
    cat("  ================ RULES ===============", "\n")
    cat(" ", paste0(object$superrule, collapse = "\n  "))

  } else {

    cat("  Original set size: ", object$N, "\n")
    cat("  Original set quality: ", object$avg.quality, "\n")
    cat("\n")
    cat("  ============== BEST BOX ==============", "\n")
    cat("  Box quality: ", object$box.qualities[best.box.idx], "(", object$box.qualities[best.box.idx] / object$avg.quality, ") \n")
    cat("  Box support: ", object$supports[best.box.idx], " (", object$supports[best.box.idx] * object$N, ") \n")
    cat("\n")
    cat("  ================ RULES ===============", "\n")
    cat(" ", paste0(object$superrule, collapse = "\n  "))
  }
}

#' @title Summarize a PRIM cover result object
#' @description Summarize a PRIM cover result object
#' @param object An S3 object of class prim.cover
#' @param ... Optional arguments to pass on
#' @param round Optional setting to disable rounding
#' @param digits Optional setting to control nr of digits to round
#' @author Jurian Baas
#' @export
summary.prim.cover <- function(object, ..., round = T, digits = 2) {

  cat("  ======================================", "\n")
  cat("  ========== PRIM COVER RESULT =========", "\n")
  cat("  ======================================", "\n")
  cat("  |\n")
  cat("  |  Peeling quantile:", object$peeling.quantile, "\n")
  cat("  |  Min support:", object$min.support, "\n")
  cat("  |  Train/test split:", object$train.fraction, "\n")
  cat("\n")

  if(round) {

    for(i in 1:length(object$covers)) {
      x <- object$covers[[i]]
      cat("\n")
      cat("  ======================================", "\n")
      cat("  ============== COVER", i,"===============", "\n")
      cat("  |  Cover set size: ", x$cov.N, "\n")
      cat("  |  Cover set quality: ", round(x$cov.avg.quality, digits), "\n")
      cat("  |\n")
      cat("  |  Box quality: ", round(x$cov.quality, digits), "(", round(x$cov.quality / x$cov.avg.quality, digits), ") \n")
      cat("  |  Box support: ", round(x$cov.support / x$cov.N, digits) , " (", x$cov.support, ") \n")

      if(!is.null(x$superrule)){
        cat("\n")
        cat("  ================ RULES ===============", "\n")
        cat("  | ", paste0(x$superrule, collapse = "\n  |  "))
      }
      cat("\n","\n","\n")

    }
  } else {

    for(i in 1:length(object$covers)) {
      x <- object$covers[[i]]
      cat("\n")
      cat("  ======================================", "\n")
      cat("  ============== COVER", i,"===============", "\n")
      cat("  |  Cover set size: ", x$cov.N, "\n")
      cat("  |  Cover set quality: ", x$cov.avg.quality, "\n")
      cat("  |\n")
      cat("  |  Box quality: ", x$cov.quality, "(", x$cov.quality / x$cov.avg.quality, ") \n")
      cat("  |  Box support: ", x$cov.support / x$cov.N , " (", x$cov.support, ") \n")

      if(!is.null(x$superrule)){
        cat("\n")
        cat("  ================ RULES ===============", "\n")
        cat("  | ", paste0(x$superrule, collapse = "\n  |  "))
      }
      cat("\n","\n","\n")
    }
  }


}

#' @description Generate a subset of the data using the rules in the supplied prim S3 object
#' @title PRIM subset creator
#' @param prim.object An S3 object of class prim.peel or prim.validate result
#' @param X A data frame with at least those columns that were used in creating the prim S3 object
#' @return A subset of X
#' @author Jurian Baas
#' @export
prim.superrule.index <- function(prim.object, X) {

  if(class(prim.object) != "prim.peel" & class(prim.object) != "prim.validate") {
    stop("Supplied argument is not of class prim.peel or prim.validate, aborting...")
  }
  return(with(X, eval(parse(text = paste0(prim.object$superrule, collapse = " & ")))))
}

#' @description This function takes the result of the prim peeling process and applies it to new data. Usually the optimal box in the peeling process is not the best on unobserved data.
#' @title Bump hunting using the Patient Rule Induction Method
#' @param peel.result An S3 object of class prim.peel
#' @param X A data frame with at least those columns that were used in creating the prim.peel S3 object
#' @param y Response vector, usually of type numeric
#' @return An S3 object of type prim.validate
#' @author Jurian Baas
#' @export
prim.validate <- function(peel.result, X, y) {

  if(class(peel.result) != "prim.peel") {
    stop("Supplied argument is not of class prim.peel, aborting...")
  }

  if(!is.data.frame(X)) stop("Paramter X has to be a data frame")
  if(!is.vector(y)) stop("Parameter y has to be a vector")
  if(nrow(X) != length(y)) stop("Parameters X and y are not of same size")

  quality.function <- peel.result$quality.function

  i <- 1

  result <- list()
  class(result) <- "prim.validate"
  result$box.qualities <- quality.function(y)
  result$supports <- 1
  result$redundant <- integer()
  result$rule.names <- character()
  result$rule.operators <- character()
  result$rule.types <- character()
  result$rule.values <- list() # A list because we store multiple types of values (i.e. numerical, logical and factors)
  result$quality.function <- quality.function
  result$N <- nrow(X)
  result$avg.quality <- quality.function(y)

  repeat {

    # Stop if there are no more boxes
    if(i > length(peel.result$rule.names)) break

    rule.info <- list(
      name = as.character(peel.result$rule.names[i]),
      operator = as.character(peel.result$rule.operators[i]),
      value = peel.result$rule.values[i],
      type = as.character(peel.result$rule.types[i])
    )

    rule <- paste( rule.info$name, rule.info$operator, rule.info$value)
    idx <- !with(X, eval(parse(text = rule)))

    # Check if this rule has any observations in the test data
    if(sum(idx) > 0) {

      X <- X[!idx,]
      y <- y[!idx]

      result$box.qualities <- c(result$box.qualities, quality.function(y))
      result$supports <- c(result$supports, length(y) / result$N)

      result$rule.values <- c(result$rule.values, rule.info$value)
      result$rule.names <- c(result$rule.names, rule.info$name)
      result$rule.operators <- c(result$rule.operators, rule.info$operator)
      result$rule.types <- c(result$rule.types, rule.info$type)

    } else {

      result$redundant <- c(result$redundant, i)

    }

    # This box could have all the remaining observations, no need to iterate further
    if(nrow(X) == 0) break

    i <- i + 1
  }

  result$rule.names <- factor(result$rule.names, levels = colnames(X))
  result$rule.operators <- factor(result$rule.operators, levels = c(">=", "<=", "==", "!="))
  result$rule.types <- factor(result$rule.types, levels = c("numeric", "logical", "factor"))

  result$superrule <- prim.condense.rules(result)
  result$call <- match.call()

  return(result)
}

#' @description This function condenses the many (redundant) rules of an S3 object of class prim.peel or prim.validate to a single rule.
#' @title Condense multiple (redundant) rules
#' @param prim.object An S3 object of class prim.peel or prim.validate
#' @return The condensed rule as a single string
#' @author Jurian Baas
prim.condense.rules <- function(prim.object) {

  if(class(prim.object) != "prim.peel" & class(prim.object) != "prim.validate"){
    stop("Supplied argument is not of class prim.peel or prim.validate, aborting...")
  }

  # Search for the rules leading up to the best box
  rule.idx <- 1:(which.max(prim.object$box.qualities)-1)

  # Combine the lists into a single data frame
  t <- data.frame (
    name = factor(prim.object$rule.names[rule.idx]),
    operator = factor(prim.object$rule.operators[rule.idx]),
    value = as.character(prim.object$rule.values[rule.idx]),
    score = prim.object$box.qualities[rule.idx],
    type = factor(prim.object$rule.types[rule.idx])
  )

  # Group by name first
  t <- by(t, t$name, function(x) {

    # Group by operator in the name subgroup
    by(x, factor( x$operator), function(y) {
      # Find the rule with the largest associated score
      y <- y[which.max( y$score),]
      # Return this rule as a proper string
      return(paste(y$name, y$operator, y$value))
    })
  })

  # Collapse to character vector
  return(unname(unlist(as.vector(t))))
}

#' @title PRIM covering algorithm
#' @description In bump hunting it is customary to follow a so-called covering strategy. This means that the same box construction (rule induction) algorithm is applied sequentially to subsets of the data.
#' @param X Data frame to find rules in
#' @param y Response vector, usually of type numeric
#' @param peeling.quantile Quantile to peel off for numerical variables
#' @param min.support Minimal size of a box to be valid
#' @param train.fraction Train-test split fraction used in validation
#' @param max.boxes Optional maximum number of boxes
#' @param quality.function Optional setting for function to use for determining subset quality, defaults to mean
#' @author Jurian Baas
#' @export
prim.cover.default <- function(X, y, peeling.quantile, min.support, train.fraction = 0.66, max.boxes = NA, quality.function = mean) {

  if(!is.data.frame(X)) stop("Paramter X has to be a data frame")
  if(!is.vector(y)) stop("Parameter y has to be a vector")
  if(nrow(X) != length(y)) stop("Parameters X and y are not of same size")
  if(peeling.quantile <= 0) stop("Peeling quantile must be positive")
  if(peeling.quantile >= 1) stop("Peeling quantile must be a fraction smaller than 1")
  if(min.support <= 0) stop("Minimum support must be positive")
  if(min.support >= 1) stop("Minimum support must be a fraction smaller than 1")
  if(train.fraction <= 0) stop("Training fraction must be positive")
  if(train.fraction >= 1) stop("Training fraction must be a fraction smaller than 1")
  if(!is.na(max.boxes) & max.boxes <= 0) stop("Maximum boxes must be a positive integer")

  N <- nrow(X) * min.support
  box.nr <- 1
  covers <- list()

  result <- list()
  result$peeling.quantile = peeling.quantile
  result$min.support = min.support
  result$train.fraction = train.fraction
  if(!is.na(max.boxes)) result$max.boxes = max.boxes
  class(result) <- "prim.cover"

  repeat {

    # In case the user set a max nr of boxes
    # Box has become too small
    if((!is.na(max.boxes) & box.nr > max.boxes) | (nrow(X) < N) ) {
      p.validate <- list()
      class(p.validate) <- "prim.validate"

      p.validate$cov.N <- nrow(X)
      p.validate$cov.support <- nrow(X)
      p.validate$cov.avg.quality <- quality.function(y)
      p.validate$cov.quality <- quality.function(y)

      covers <- c(covers, list(p.validate))
      break
    }

    train <- sample(1:nrow(X), nrow(X) * train.fraction)

    p.train <- prim.default(X[train,], y[train], peeling.quantile, min.support, quality.function)
    p.validate <- prim.validate(p.train, X[-train,], y[-train])

    idx <- prim.superrule.index(p.validate, X)

    p.validate$cov.N <- nrow(X)
    p.validate$cov.support <- sum(idx)
    p.validate$cov.avg.quality <- quality.function(y)
    p.validate$cov.quality <- quality.function(y[idx])

    X <- X[!idx,]
    y <- y[!idx]
    box.nr <- box.nr + 1

    covers <- c(covers, list(p.validate))

  }

  result$covers <- covers
  return(result)
}

#' @title PRIM covering algorithm
#' @description In bump hunting it is customary to follow a so-called covering strategy. This means that the same box construction (rule induction) algorithm is applied sequentially to subsets of the data.
#' @param formula Formula with a response and terms
#' @param data Data frame to find rules in
#' @param peeling.quantile Quantile to peel off for numerical variables
#' @param min.support Minimal size of a box to be valid
#' @param train.fraction Train-test split fraction used in validation
#' @param max.boxes Optional maximum number of boxes
#' @param quality.function Optional setting for function to use for determining subset quality, defaults to mean
#' @author Jurian Baas
#' @export
prim.cover.formula <- function(formula, data, peeling.quantile, min.support, train.fraction = 0.66, max.boxes = NA, quality.function = mean) {

  if(!is.data.frame(data)) stop("Data argument is not a data frame, aborting...")

  X <- stats::model.frame(formula = formula, data = data)
  y <- stats::model.response(X)
  X <- X[,-1]

  if(is.null(y)) stop("Data has no response variable, aborting...")

  result <- prim.cover.default(X, y, peeling.quantile, min.support, train.fraction, max.boxes, quality.function)
  result$formula <- formula

  return(result)
}

#' @title PRIM main entrance
#' @description Temporary description
#' @author Jurian Baas
#' @export
prim <- function() {

}

