


#' This function goes through all columns of the dataset and tries to find
#' box candidates based on the quantile alpha and minimum support min.support.
#' Note that the indexes returned are those that have to be removed in order to create the box!
#'
#' @param x Data frame with observations (may be a subset of original data)
#' @param y Quantile to peel off
#' @param min.support Minimal size of a box
#' @param N Number of rows of original subset
#' @return A list of potential boxes
#' @author Jurian Baas
#' @examples
#' prim.candidates.find(myData, 0.01, 0.4, nrow(myData))
#' prim.candidates.find(myDataSubset, 0.01, 0.4, nrow(myData))
.prim.candidates.find <- function(X, alpha, min.support, N) {

  c <- lapply(X, function(col) {

    b <- list()
    r <- list()

    # Do something different depending on data type
    if(is.numeric(col)) {

      b.min <- which(col < quantile(col, alpha))
      b.plus <- which(col > quantile(col, 1-alpha))

      # Make sure the resulting subsets have enough support
      if(length(b.min) > 0 & (length(col) - length(b.min)) / N >= min.support) {
        b <- c(b, idx.min = list(b.min))
        r <- c(r, rule.min = paste("<", quantile(col, alpha)))
      }
      if(length(b.plus) > 0 & (length(col) - length(b.plus)) / N >= min.support) {
        b <- c(b, idx.plus = list(b.plus))
        r <- c(r, rule.plus = paste(">", quantile(col, 1-alpha)))
      }

    } else if (is.logical(col)  ) {

      if(any(col) & any(!col)) {
        b.min <- which(col)
        b.plus <- which(!col)

        # Make sure the resulting subsets have enough support
        if((sum(!col) / N) >= min.support) {
          b <- c(b, idx.min = list(b.min))
          r <- c(r, rule.min = paste("==", "TRUE"))
        }
        if((sum(col) / N) >= min.support) {
          b <- c(b, idx.plus = list(b.plus))
          r <- c(r, rule.plus = paste("==", "FALSE"))
        }
      }

    } else if (is.factor(col)) {

      # Reset levels just to be sure, so we don't use levels that no
      # longer exist due to them being removed in some previous iteration
      col <- factor(col)

      r <- lapply(levels(col), function(lvl) {
        paste("==", lvl)
      })
      # Create a box candidate for each level
      b <- lapply(levels(col), function(lvl) {

        box <- which(col == lvl)

        # Make sure the resulting subsets have enough support
        if((length(col) - length(box)) / N >= min.support) {
          return(box)
        }
        return(NA)
      })

      # Remove any NA's
      r <- r[!is.na(b)]
      b <- b[!is.na(b)]

    }

    return(list(rule = r, idx = b))

  })
  # Remove empty elements from the list
  c <- Filter(Negate(function(x) is.null(unlist(x))), c)
  return(c)
}

#' This function calculates the quality of the dependant variable y given some box candidate
#'
#' @param y Vector of values on which to determine the quality
#' @param candidates List of candidates generated by .prim.candidates.find()
#' @param quality.function Function to use for a quality measure (usually mean)
#' @return A list with the qualities of each supplied candidate box
#' @author Jurian Baas
.prim.candidates.quality <- function(y, candidates, quality.function ) {

  # Extract index information
  candidates.idx <- lapply(candidates, function(box){box$idx})

  lapply(candidates.idx, function(c) {
    sapply(c, function(idx){
      quality.function(y[-idx])
    })
  })
}

#' This function goes through the box candidate qualities and finds the optimal candidate
#'
#' @param candidates.quality List of candidate qualities generated by .prim.candidates.quality()
#' @return Index of the optimal candidate in the candidates.quality argument
#' @author Jurian Baas
.prim.candidates.best <- function(candidates.quality) {

  # Find the best value for each column
  m <- sapply(candidates.quality, function(x) c(idx = which.max(x), value = max(x)))
  # Find the best value among the previous best
  m.index <- which.max(m[2,])
  m.subindex <- m[1,m.index]

  names(m.index) <- names(candidates.quality)[m.index]

  # Return the indexes
  return(c(m.index, m.subindex))
}

#' Main function for bump hunting using the Patient Rule Induction Method (PRIM).
#'
#' @param X Data frame to find rules in
#' @param y Response vector, usually of type numeric
#' @param alpha Quantile to peel off for numerical variables
#' @param min.support Minimal size of a box to be valid
#' @param quality.funciton Which function to use to determine the quality of a box, defaults to mean
#' @return An object of class prim.peel.result
#' @author Jurian Baas
prim <- function(X, y, alpha, min.support, quality.function = mean) {

  result <- list()
  result$box.qualities <- quality.function(y)
  result$supports <- 1
  result$rules <- character()
  result$quality.function <- quality.function

  N <- nrow(X)

  repeat {

    if(nrow(X) / N <= min.support) break

    # Find box candidates
    candidates <- .prim.candidates.find(X, alpha, min.support, N)

    if(length(candidates) == 0) break

    candidates.quality <- .prim.candidates.quality(y, candidates, quality.function)
    candidates.final <- .prim.candidates.best(candidates, candidates.quality)

    idx <- unlist(candidates[[ candidates.final[1] ]]$idx[candidates.final[2]])
    rule <- unlist(candidates[[ candidates.final[1] ]]$rule[candidates.final[2]])
    rule <- paste(names(candidates.final)[1], rule)

    X <- X[-idx,]
    y <- y[-idx]

    result$box.qualities <- c(result$box.qualities, quality.function(y))
    result$supports <- c(result$supports, length(y)/N)
    result$rules <- c(result$rules, rule)
  }

  class(result) <- "prim.peel.result"

  result$superrule <- .prim.condense.rules(result)

  return(result)
}

#' Plot an object of class prim.peel.result
#' @param peel.result An object of class prim.peel.result
#' @author Jurian Baas
plot.prim.peel.result <- function(peel.result) {
  plot(peel.result$supports, peel.result$box.qualities, col= "blue", pch = 19, cex = 1, lty = "solid", lwd = 2, xlab = "Support", ylab = "Box quality", main = "PRIM peel result")
  text(peel.result$supports, peel.result$box.qualities, labels=c("", peel.result$rules), cex = 0.7, pos = 4)
}

#' Plot an object of class prim.test.result
#' @param An object of class prim.test.result
#' @author Jurian Baas
plot.prim.test.result <- function(test.result) {
  plot(test.result$supports, test.result$box.qualities, col= "blue", pch = 19, cex = 1, lty = "solid", lwd = 2, xlab = "Support", ylab = "Box quality", main = "PRIM test result")
  text(test.result$supports, test.result$box.qualities, labels=c("", test.result$rules), cex = 0.7, pos = 4)
}

#' Generate a subset of the data using the rules in the supplied prim object
#'
#' @param prim.object An object of class prim.peel.result or prim.test result
#' @param X A data frame with at least those columns that were used in creating the prim object
#' @return A subset of X
#' @author Jurian Baas
prim.subset.box <- function(prim.object, X) {

  if(class(prim.object) != "prim.peel.result" & class(prim.object) != "prim.test.result") {
    error("Supplied argument is not of class prim.peel.result or prim.test.result, aborting...")
  }
  return(subset(X, eval(parse(text = prim.object$superrule))))
}

#' This function takes the result of prim() and applies it to new data. Usually the optimal box in the peeling process
#' is not the best on unobserved data.
#'
#' @param peel.result An object of class prim.peel.result
#' @param X A data frame with at least those columns that were used in creating the prim.peel.result object
#' @param y Response vector, usually of type numeric
#' @return An object of type prim.test.result
#' @author Jurian Baas
prim.test <- function(peel.result, X, y) {

  if(class(peel.result) != "prim.peel.result") {
    error("Supplied argument is not of class prim.peel.result, aborting...")
  }

  quality.function <- peel.result$quality.function

  N <- nrow(X)
  i <- 1
  supports <- 1
  qualities <- quality.function(y)
  rules <- character()
  redundant <- integer()

  repeat {
    if(i > length(peel.result$rules)) break

    rule <- paste0("X$", peel.result$rules[i])

    idx <- which( eval(parse(text = rule)))

    if(length(idx) > 0) {

      X <- X[-idx,]
      y <- y[-idx]

      qualities <- c(qualities, quality.function(y))
      supports <- c(supports, length(y) / N)
      rules <- c(rules, peel.result$rules[i])

    } else {

      redundant <- c(redundant, i)

    }

    i <- i + 1
  }

  t <- list(
    box.qualities = qualities,
    supports = supports,
    rules = rules,
    redundant = redundant)
  class(t) <- "prim.test.result"
  t$superrule <- .prim.condense.rules(t)

  return(t)
}

#' This function condenses the many (redundant) rules of an object of class
#' prim.peel.result or prim.test.result to a single rule.
#'
#' @param prim.object An object of class prim.peel.result or prim.test.result
#' @return The condensed rule as a single string
#' @author Jurian Baas
.prim.condense.rules <- function(prim.object) {

  if(class(prim.object) != "prim.peel.result" & class(prim.object) != "prim.test.result"){
    error("Supplied argument is not of class prim.peel.result or prim.test.result, aborting...")
  }

  # Search for the rules leading up to the best box
  rules <- prim.object$rules[1:(which.max(prim.object$box.qualities)-1) ]

  t <- data.frame(t(sapply(rules, function(x) {

    sign.st <- grepl("<", x, fixed = T)
    sign.lt <- grepl(">", x, fixed = T)
    sign.eq <- grepl("==", x, fixed = T)

    split <- strsplit(x, "<|>|==")[[1]]

    return(c(split[1], split[2], sign.st, sign.lt, sign.eq))
  })))

  colnames(t) <- c("col", "value", "sign.st", "sign.lt", "sign.eq")
  t$col <- factor(t$col)
  t$value <- as.numeric(levels(t$value))[t$value]

  t <- by(t, list(t$col, t$sign.st, t$sign.lt, t$sign.eq), function(x) {

    if(!is.null(x)) {

      st <- all(as.logical(x$sign.st))
      lt <- all(as.logical(x$sign.lt))
      eq <- all(as.logical(x$sign.eq))

      if(st & !lt & !eq) {

        x.best <- x[which.min(x$value),]
        return(paste(x.best$col, ">=", x.best$value))

      } else if(!st & lt & !eq) {

        x.best <- x[which.max(x$value),]
        return(paste(x.best$col, "<=", x.best$value))

      } else if (!st & !lt & eq){

        return(paste(x$col, "!=", x$value))

      }
    }
    return("")
  })

  t <- t[sapply(t, function(x){x != ""})]

  return(paste(t, collapse = " & "))
}





